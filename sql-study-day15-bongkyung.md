## 11 - 1 하나의 단위로 데이터를 처리하는 트랜잭션
<br/>


>트랜잭션이란?

- 트랜잭션이란 더 이상 분할할 수 없는 최소 수행 단위를 뜻하며 계좌 이체와 같이 하나의 작업 또는 밀접하게 연관된 작업을 수행하기 위해 한 개 이상의 데이터 조작 명령어(DML)로 이루어진다. 즉 어떤 기능 한 가지를 수행하는 'SQL문 덩어리'라고 볼 수 있다.
트랜잭션은 하나의 트랜잭션 내에 있는 여러 명령어를 한 번에 수행하여 작업을 완료하거나 아예 모두 수행하지 않는 상태, 즉 모든 작업을 취소한다. 이러한 특성으로 트랜잭션 의미를 'ALL OR NOTHING'문장을 설명하기도 한다. 그리고 트랜잭션을 제어하기 위해 사용하는 명령어를 TCL(Transaction Control Language)이라고 한다.
<br/>

## 11 - 2 트랜잭션을 제어하는 명령어
<br/>

- 트랜잭션 개념을 통해 알 수 있듯이 하나의 트랜잭션에 묶여 있는 데이터 조작어(DML)의 수행 상태는 모든 명령어가 정상적으로 수행 완료된 상태 또는 모든 명령어가 수행되지 않아 취소된 상태, 이 두 가지 상태로만 존재할 수 있다. 트랜잭션 제어 명령어는 데이터 조작 상태를 이 두 가지 상태 중 하나로 유도하는 명령어를 의미한다.
즉 데이터 조작을 데이터 베이스에 영구히 반영하거나 작업 전체를 취소한다.
<br/>

```sql
// DEPT 테이블을 복사해서 DEPT_TCL 테이블 만들기
CREATE TABLE DEPT_TCL
	AS SELECT *
    	 FROM DEPT;
```

```sql
// DEPT_TCL 테이블에 데이터를 입력•수정•삭제하기
// 명령어는 각각 한 번씩 따로 실행
INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', 'SEOUL');

UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;

DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';

SELECT * FROM DEPT_TCL;
```
<br/>

>트랜잭션을 취소하고 싶을 때는 ROLLBACK

- 위에서 실행한 세 개의 데이터 조작어는 중간에 별다른 작업이 없었다면 하나의 트랜잭션에 속해 있을 것이다. 만약 이 모든 작업의 수행을 취소하고 싶다면 ROLLBACK(롤백) 명령어를 사용한다.
ROLLBACK은 현재 트랜잭션에 포함된 데이터 조작 관련 명령어의 수행을 모두 취소한다.
```sql
// ROLLBACK으로 명령어 실행 취소하기
ROLLBACK;
```
▶︎ 결과를 보면 최초 DEPT_TCL 테이블을 생성한 직후의 데이터로 되돌아간 것을 확인할 수 있다.
<br/>

>트랜잭션을 영원히 반영하고 싶을 때는 COMMIT

- ROLLBACK과 달리 지금까지 수행한 트랜잭션 명령어를 데이터베이스에 영구히 반영할 때는 COMMIT(커미트) 명령어를 사용한다.
```sql
// DEPT_TCL 테이블에 데이터를 입력•수정•삭제하기
// 명령어는 각각 한 번씩 따로 실행
INSERT INTO DEPT_TCL VALUES(50, 'NETWORK', 'SEOUL');

UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 20;

DELETE FROM DEPT_TCL WHERE DEPTNO = 40;

SELECT * FROM DEPT_TCL;
```
```sql
// COMMIT으로 명령어 반영하기
COMMIT;
```
▶︎ COMMIT 명령어는 지금까지 트랜잭션에서 데이터 조작 관련 명령어를 통해 변경된 데이터를 모두 데이터베이스에 영구히 반영한다. ROLLBACK 명령어 역시 이 시점부터는 소용이 없다. 그러므로 COMMIT은 트랜잭션 작업이 정상적으로 수행되었다고 확신할 때 사용해야 한다.
<br/>

⭐️ COMMIT, ROLLBACK 명령어 모두 현재 트랜잭션을 끝내고 새 트랜잭션을 시작하게 한다. 종료될 트랜잭션에 작업을 반영할지 취소할지만 결정하는 것이다.

---
<br/>

## 11 - 3 세션과 읽기 일관성의 의미
<br/>

>세션이란?

- 세션(session)은 어떤 활동을 위한 시간이나 기간을 뜻한다. 오라클 데이터베이스에서 세션은 데이터베이스 접속을 시작으로 여러 데이터베이스에서 관련 작업을 수행한 후 접속을 종료하기까지 전체 기간을 의미한다.
그러므로 세션이 여러 개라는 말을 현재 오라클 데이터베이스에 접속하여 사용 중인 연결이 여러 개 있다는 뜻이다.
- 트랜잭션과 세션의 관계에서 트랜잭션은 데이터 조작 명령어가 모인 하나의 작업 단위를 뜻하며 세션 내부에는 하나 이상의 트랜잭션이 존재한다. 왜냐하면 데이터베이스에 접속한 후 종료하기까지의 과정이 하나의 세션이고 이 세션이 유지되는 동안 여러 COMMIT, ROLLBACK 작업이 진행되기 때문이다.
`⭐️ 세션이 트랜잭션보다 큰 범위의 개념임을 잊지 말자!`
<br/>

>읽기 일관성의 중요성

- 데이터베이스는 여러 곳(여러 사용자, 여러 응용 프로그램)에서 동시에 접근하여 데이터를 관리•사용하는 것이 목적이므로 대부분 수많은 세션이 동시에 연결되어 있다. 읽기 일관성이란 어떤 특정 세션에서 테이블의 데이터를 변경 중일 때 그 외 다른 세션에서는 데이터의 변경이 확정되기 전까지 변경 사항을 알 필요가 없으므로, 데이터를 변경 중인 세션을 제외한 나머지 세션에서는 현재 진행 중인 변경과 무관한 본래의 데이터를 보여 주는 특성을 의미한다.
<br/>

- SQL Developer와 SQL * PLUS로 세션 알아보기 1

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| SELECT * FROM DEPT_TCL; <-1. | SELECT * FROM DEPT_TCL; <-2. |

▶︎ 두 세션 모두 똑같은 DEPT_TCL 테이블을 조회했으므로 조회 결과는 같다.
<br/>

- SQL Developer와 SQL * PLUS로 세션 알아보기 2

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| DELETE FROM DEPT_TCL<br/> WHERE DEPTNO = 50; <- 1. | 세션 A의 DELETC 명령이 끝날 때까지 기다려 주세요. |
| SELECT * FROM DEPT_TCL; <- 2. | SELECT * FROM DEPT_TCL; <- 3. |

▶︎ 세션 알아보기2의 결과에서 세션 A에서는 50번 부서가 삭제된 상태로 DETP_TCL 테이블이 조회되자만 세션 B에서는 50번 부서가 아직 삭제되지 않은 상태, 즉 변경이 일어나기 전 상태로 출력된다.
이는 세션 A에서 실행한 DELETE문의 수행 결과가 데이터베이스에 완벽하게 반영되지 않았기 때문이다. 즉 COMMIT되지 않았다는 이야기이다. COMMIT 명령어로 세션 A에서 실행한 DELETE문의 실행 결과가 데이터베이스에 영구히 반영되기 전까지 DELETE를 실행한 세션 A를 제외한 다른 세션에서는 50번 부서 데이터의 변화를 확인할 수 없다.
이와 같이 어떤 데이터 조작이 포함된 트랜잭션이 완료(COMMIT, ROLLBACK)되기 전까지 데이터를 직접 조작하는 세션 외 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회•출력•검색되는 특성을 '읽기 일관성(read consistency)'이라고 한다.
⭐️ 중요한 내용이니 꼭 기억하자!

- SQL Developer와 SQL * PLUS로 세션 알아보기 3

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| COMMIT; <-1 | 세션 A의 COMMIT 명령이 끝날 때까지 기다려 주세요. |
| SELECT * FROM DEPT_TCL; <- 2 | SELECT * FROM DEPT_TCL; <- 3 |

▶︎ 세션 알아보기3과 같이 세션 A에서 COMMIT 실행 후에는 세션 알아보기2에서 실행한 50번 부서를 삭제하는 DELETE문 수행 결과가 데이터베이스에 완전히 반영된다. 따라서 세션 B에서도 50번 부서가 삭제된 채 조회되는 것을 확인할 수 있다.
<br/>

- 하나의 데이터베이스에는 수많은 세션이 연결되고각 세션에서는 데이터 조작 명령어가 포함된 여러 트랜잭션이 끊임없이 시작되고 종료되면서 실시간으로 작업이 수행된다. 데이터를 직접 변경 중인 해당 세션을 제외한 모든 세션은 다든 세션의 데이터 변경과 상관없이 이미 확정된 데이터만 검색됨으로써 읽기 일관성을 보장할 수 있다.

---
<br/>

## 11 - 4 수정 중인 데이터 접근을 막는 LOCK
<br/>

>LOCK이란?

- 특정 세션에서 조작 중인 데이터는 트랜잭션이 완료(COMMIT, ROLLBACK)되기 전까지 다른 세션에서 조작할 수 없는 상태가 된다. 즉 데이터가 잠기는(LOCK) 것이다. LOCK은 조작 중인 데이터를 다른 세션은 조작할 수 없도록 접근을 보류시키는 것을 뜻한다.
<br/>

>LOCK 개념 살펴보기

- SQL Developer와 SQL * PLUS로 LOCK 알아보기 1

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| SELECT * FROM DEPT_TCL; <-1. | SELECT * FROM DEPT_TCL; <-2. |

- SQL Developer와 SQL * PLUS로 LOCK 알아보기 2

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| UPDATE DEPT_TCL SET LOC='SEOUL'<br/> WHERE DEPTNO = 30; <- 1. | 세션 A의 UPDATE 명령이 끝날 때까지 기다려 주세요. |
| SELECT * FROM DEPT_TCL; <- 2. | SELECT * FROM DEPT_TCL; <- 3. |

▶︎ UPDATE문을 실행하고 있는 세션 A에서는 30번 부서의 LOC열이 SEOUL로 변경되었지만 COMMIT은 되지 않은 상태이므로 세션 B에서는 30번 부서에 변화가 없다.

- SQL Developer와 SQL * PLUS로 LOCK 알아보기 3

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| A는 아무런 작업을 하지 않습니다. | UPDATE DEPT_TCL SET DNAME='DATABASE'<br/> WHERE DEPTNO = 30; <- 1. |

▶︎ 세션 B에서 UPDATE문을 작성하고 실행하면 아무런 동작이 일어나지 않는다. SQL * PLUS 화면을 보면 화면이 멈춘 듯 가만히 있을 것이다.

- 이는 세션 A에서 DEPT_TCL 테이블의 30번 부서 데이터를 먼저 조작하고 있기 때문이다. 세션 A에서 수행 중인 30번 부서 행 데이터의 조작이 완료되지 않았기 때문에 COMMIT 또는 ROLLBACK을 수행하기 전까지 30번 부서 행 데이터를 조작하려는 다른 세션은 작업을 대기하게 된다. 이렇게 특정 세션에서 데이터 조작이 완료될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상을 HANG(행)이라고 한다.
세션 B의 UPDATE문은 세션 A의 현재 트랜잭션이 종료되기 전까지는 수행되지 못한다. 즉 세션 A에서 COMMIT으로 데이터 변경을 확정하여 반영하거나, ROLLBACK으로 세션 A의 UPDATE문 실행을 취소해야만 30번 부서 데이터의 LOCK이 풀린다. 그리고 데이터의 LOCK이 풀린 즉시 세션 B는 UPDATE문을 실행한다.
<br/>

- SQL Developer와 SQL * PLUS로 LOCK 알아보기 4

| 세션 A(SQL Developer) | 세션 B(SQL * PLUS) |
|:--------------:|:------------:|
| COMMIT; <- 1. | 세션 A의 COMMIT 명령어가 실행되는 순간의 변화를 확인합니다. |

▶︎ 세션 A에서 COMMIT 명령어를 실행하는 순간 세션 B의 UPDATE문이 실행된 것을 확인할 수 있다. 세션 A에 의해 LOCK 상태였던 30번 부서 데이터가 COMMIT 명령어로 트랜잭션이 완료되어 LOCK이 풀렸고, 이와 동시에 30번 부서 데이터 작업을 기다리고 있던 세션 B의 UPDATE문이 실행된 것이다.
<br/>

>LOCK 종류

- LOCK은 하나의 데이터를 여러 곳에서 동시에 조작하려 할 때 발생할 수 있는 혼란을 최소화하기 위한 중요한 요소이다. SQL문으로 조작하는 대상 데이터가 테이블의 특정 행 데이터일 경우에 해당 행만 LOCK이 발생한다는 의미로 '행 레벨 록(row level lock)'이라고 정의한다.
만약 다음과 같이 WHERE절을 지정하지 않은 UPDATE, DELETE문일 경우에는 테이블의 모든 행 데이터에 영향을 주는 명령어이므로 이 경우에는 테이블에 저장되어 있는 전체 행이 LOCK 상태가 된다. 즉 다른 세션에서는 해당 테이블에 이미 저장되어 있는 행에 UPDATE, DELETE 명령을 수행하기 위해서 대기해야 한다. 하지만 테이블 전체 행이 LOCK 상태여도 INSERT문의 수행은 가능하다.
```sql
UPDATE DEPT_TCL SET LOC = 'SEOUL';

DELETE FROM DEPT_TCL;
```

- 하지만 테이블에 변경되는 행의 수와는 상관없이 데이터 조작 명령어를 사용하여 데이터가 변경 중인 테이블은 테이블 단위 잠금이라는 의미로 '테이블 레벨 록(table level lock)'이 걸리게 된다. 즉 데이터를 변경 중인 세션 외 다른 세션에서 12장에서 살펴볼 데이터 정의어(DDL)를 통한 테이블의 구조를 변경할 수는 없다.
데이터 조작 관련 SQL문을 어떤 방식으로 작성하느냐에 따라 테이블의 일부 데이터만 LOCK이 될 수도 있고 테이블 전체 데이터가 LOCK이 될 수도 있다는 점을 기억하자.

---
---
